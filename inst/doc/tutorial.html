<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Bo Zhang, University of Pennsylvania" />


<title>Tutorial for R Package match2C</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Tutorial for R Package match2C</h1>
<h4 class="author">Bo Zhang, University of Pennsylvania</h4>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">options</span>(<span class="dt">scipen =</span> <span class="dv">99</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">options</span>(<span class="dt">digits =</span> <span class="dv">2</span>)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">library</span>(match2C)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">library</span>(ggplot2)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#&gt; Warning: package &#39;ggplot2&#39; was built under R version 4.0.5</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">library</span>(mvtnorm)</span></code></pre></div>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p>To run all functionalities in this tutorial, one needs to first install the package optmatch and agree to its terms of use. Package optmatch may be downloaded from <a href="https://github.com/markmfredrickson/optmatch" class="uri">https://github.com/markmfredrickson/optmatch</a> if not available on CRAN.</p>
<div id="preparation-of-data" class="section level2">
<h2>Preparation of data</h2>
<p>This file serves as an introduction to the <strong>R</strong> package <strong>match2C</strong>. We first load the package and an illustrative dataset from Rouse (1995). For the purpose of illustration, we will mostly work with 6 covariates: two nominal (black and female), two ordinal (father’s education and mother’s education), and two continuous (family income and test score). Treatment is an instrumental-variable-defined exposure, equal to <span class="math inline">\(1\)</span> if the subject is doubly encouraged, meaning the both the excess travel time and excess four-year college tuition are larger than the median, and to be <span class="math inline">\(0\)</span> if the subject is doubly discouraged. There are <span class="math inline">\(1,122\)</span> subjects that are doubly encouraged (treated), and <span class="math inline">\(1,915\)</span> that are doubly discouraged (control).</p>
<p>Below, we specify covariates to be matched (X) and the exposure (Z), and fit a propensity score model.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">attach</span>(dt_Rouse)</span>
<span id="cb2-2"><a href="#cb2-2"></a>X =<span class="st"> </span><span class="kw">cbind</span>(female,black,bytest,dadeduc,momeduc,fincome) <span class="co"># covariates to be matched</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>Z =<span class="st"> </span>IV <span class="co"># IV-defined exposure in this dataset</span></span>
<span id="cb2-4"><a href="#cb2-4"></a></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="co"># Fit a propensity score model</span></span>
<span id="cb2-6"><a href="#cb2-6"></a>propensity =<span class="st"> </span><span class="kw">glm</span>(IV<span class="op">~</span>female<span class="op">+</span>black<span class="op">+</span>bytest<span class="op">+</span>dadeduc<span class="op">+</span>momeduc<span class="op">+</span>fincome,</span>
<span id="cb2-7"><a href="#cb2-7"></a>                 <span class="dt">family=</span>binomial)<span class="op">$</span>fitted.values</span>
<span id="cb2-8"><a href="#cb2-8"></a></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="co"># Number of treated and control</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>n_t =<span class="st"> </span><span class="kw">sum</span>(Z) <span class="co"># 1,122 treated</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>n_c =<span class="st"> </span><span class="kw">length</span>(Z) <span class="op">-</span><span class="st"> </span>n_t <span class="co"># 1,915 control</span></span>
<span id="cb2-12"><a href="#cb2-12"></a></span>
<span id="cb2-13"><a href="#cb2-13"></a>dt_Rouse<span class="op">$</span>propensity =<span class="st"> </span>propensity</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="kw">detach</span>(dt_Rouse)</span></code></pre></div>
</div>
<div id="glossary-of-matching-terms" class="section level2">
<h2>Glossary of Matching Terms</h2>
<p>We define some useful statistical matching terminologies:</p>
<ul>
<li><p><strong>Bipartite Matching</strong>: Matching control subjects to treated subjects based on a binary treatment status.</p></li>
<li><p><strong>Tripartite Matching</strong>: Matching control subjects to treated subjects based on a tripartite network. A tripartite network consists of two bipartite networks: a left network and a right network, where the right network is a mirror copy of the left network in nodes, but with possibly different distance structure. Typically the left network is responsible for close pairing and the right network is responsible for balancing; See Zhang et al., 2021 for details.</p></li>
<li><p><strong>Pair Matching</strong>: Matching one control subject to one treated subject.</p></li>
<li><p><strong>Optimal Matching</strong>: Matching control subjects to treated subjects such that some properly defined sum of total distances is minimized.</p></li>
<li><p><strong>Propensity Score</strong>: The propensity score is the conditional probability of assignment to a particular treatment given a vector of observed covariates (Rosenbaum and Rubin, 1983).</p></li>
<li><p><strong>Mahalanobis Distance</strong>: A multivariate measure of covariate distance between units in a sample (Mahalanobis, 1936). The squared Mahalanobis distance is equal to the difference in covariate values of treated units and matched control units, divided by the covariate’s standard deviation. Mahalanobis distance takes into account the correlation structure among covariates. The distance is zero if two units have the same value for all covariates and increases as two units become more dissimilar.</p></li>
<li><p><strong>Exact Matching</strong>: Matching cases to controls requiring the same value of a nominal covariate.</p></li>
<li><p><strong>Fine Balance</strong>: A matching technique that balances exactly the marginal distribution of one nominal variable or the joint distribution of several nominal variables in the treated and control groups after matching (Rosenbaum et al., 2007; Yu et al., 2020).</p></li>
</ul>
<p>For more details on statistical matching and statistical inference procedures after matching, see <em>Observational Studies</em> (Rosenbaum, 2002) and <em>Design of Observational Studies</em> (Rosenbaum, 2010).</p>
</div>
</div>
<div id="statistical-matching-workflow-match-check-blance-and-possibly-iterate" class="section level1">
<h1>Statistical Matching Workflow: Match, Check Blance, and (Possibly) Iterate</h1>
<div id="an-overview-of-the-family-of-three-matching-functions-match_2c-match_2c_mat-and-match_2c_list" class="section level2">
<h2>An Overview of the Family of Three Matching Functions <em>match_2C</em>, <em>match_2C_mat</em>, and <em>match_2C_list</em></h2>
<p>In the package <strong>match2C</strong>, three functions are primarily responsible for the main task statistical matching. These three functions are <em>match_2C</em>, <em>match_2C_mat</em>, and <em>match_2C_list</em>. We will examine more closely their differences and illustrate their usage with numerous examples in later sections. In this section we give a high-level outline of what each of them does. In short, the three functions have the same output format (details in the next section), but are different in their inputs.</p>
<p>Function <em>match_2C_mat</em> takes as input at least one distance matrix. A distance matrix is a n_t-by-b_c matrix whose ij-th entry encodes a measure of distance (or similarity) between the i-th treated and the j-th control subject. Hence, function <em>match_2C_mat</em> is most handy for users who are familiar with constructing and working with distance matrices. One commonly-used way to construct a distance matrix is to use the function <em>match_on</em> in the package <strong>optmatch</strong> (Hansen, 2007).</p>
<p>Function <em>match_2C_list</em> is similar to <em>match_2C_mat</em> except that it requires at least one distance list as input. A list representation of a treatment-by-control distance matrix consists of the following arguments:</p>
<ul>
<li><em>start_n</em>: a vector containing the node numbers of the start nodes of each arc in the network.</li>
<li><em>end_n</em>: a vector containing the node numbers of the end nodes of each arc in the network.</li>
<li><em>d</em>: a vector containing the integer cost of each arc in the network.</li>
</ul>
<p>Nodes 1,2,…,n_t correspond to <em>n_t</em> treatment nodes, and n_t + 1, n_t + 2, …, n_t + n_c correspond to <em>n_c</em> control nodes. Note that <em>start_n</em>, <em>end_n</em>, and <em>d</em> have the same lengths, all of which equal to the number of edges. Functions <em>create_list_from_scratch</em> and <em>create_list_from_mat</em> in the package allow users to construct a (possibly sparse) distance list with a possibly user-specified distance measure. We will discuss how to construct distance lists in later sections.</p>
<p>Function <em>match_2C</em> is a wrap-up of <em>match_2C_list</em> with pre-specified distance list structures. For the left network, a Mahalanobis distance between covariates X is adopted; For the right network, an L-1 distance between the propensity score is used. A large penalty is applied so that the algorithm prioritizes balancing the propensity score distributions in the treated and matched control groups, followed by minimizing the sum of within-matched-pair Mahalanobis distances. Function <em>match_2C</em> further allows fine-balancing the joint distribution of a few key covariates. The hierarchy goes in the order of fine-balance &gt;&gt; propensity score distribution &gt;&gt; within-pair Mahalanobis distance.</p>
</div>
<div id="object-returned-by-match_2c-match_2c_mat-and-match_2c_list" class="section level2">
<h2>Object Returned by <em>match_2C</em>, <em>match_2C_mat</em>, and <em>match_2C_list</em></h2>
<p>Objects returned by the family of matching functions <em>match_2C</em>, <em>match_2C_mat</em>, and <em>match_2C_list</em> are the same in format: a list of the following three elements:</p>
<ul>
<li><p><em>feasible</em>: 0/1 depending on the feasibility of the matching problem;</p></li>
<li><p><em>data_with_matched_set_ind</em>: a data frame that is the same as the original data frame, except that a column called <em>matched_set</em> and a column called <em>distance</em> are added to it. Variable <em>matched_set</em> assigns 1,2,…,n_t to each matched set, and NA to controls not matched to any treated. Variable <em>distance</em> records the control-to-treated distance in each matched pair, and assigns NA to all treated and controls that are left unmatched. If matching is not feasible, NULL will be returned;</p></li>
<li><p><em>matched_data_in_order</em>: a data frame organized in the order of matched sets and otherwise the same as <em>data_with_matched_set_ind</em>. Null will be returned if the matching is unfeasible.</p></li>
</ul>
<p>Let’s take a look at an example output returned by the function <em>match_2C_list</em>. The matching problem is indeed feasible:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="co"># Check feasibility</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>matching_output_example<span class="op">$</span>feasible</span></code></pre></div>
<p>Let’s take a look at the data frame <em>data_with_matched_set_ind</em>. Note that it is indeed the same as the original dataset except that a column <em>matched_set</em> and a column <em>distance</em> are appended. Observe that the first six instances belong to <span class="math inline">\(6\)</span> different matched sets; therefore <em>matched_set</em> is from <span class="math inline">\(1\)</span> to <span class="math inline">\(6\)</span>. The first six instances are all treated subjects so <em>distance</em> is NA.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># Check the original dataset with two new columns</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">head</span>(matching_output_example<span class="op">$</span>data_with_matched_set_ind, <span class="dv">6</span>)</span></code></pre></div>
<p>Finally, <em>matched_data_in_order</em> is <em>data_with_matched_set_ind</em> organized in the order of matched sets. Note that the first <span class="math inline">\(2\)</span> subjects belong to the same matched set; the next two subjects belong to the second matched set, and etc.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a><span class="co"># Check dataframe organized in matched set indices</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="kw">head</span>(matching_output_example<span class="op">$</span>matched_data_in_order, <span class="dv">6</span>)</span></code></pre></div>
</div>
<div id="checking-balance" class="section level2">
<h2>Checking Balance</h2>
<p>Statistical matching belongs to the design stage of an observational study. The ultimate goal of statistical matching is to embed observational data into an approximate randomized controlled trial and the matching process should always be conducted without access to the outcome data. Not looking at the outcome at the design stage means researchers could in principle keep adjusting their matched design until some pre-specified design goal is achieved. A rule of thumb is that the standardized differences of each covariate, i.e., difference in means after matching divided by pooled standard error before matching, is less than 0.1.</p>
<p>Function <em>check_balance</em> in the package provides simple balance check and visualization. In the code chunk below, <em>matching_output_example</em> is an object returned by the family of matching functions <em>match_2C_list</em>/<em>match_2C</em>/<em>match_2C_mat</em> (we give details on how to use these functions later). Function <em>check_balance</em> then takes as input a vector of treatment status Z, an object returned by match_2C (or match_2C_mat or match_2C_list), a vector of covariate names for which we would like to check balance, and output a balance table.</p>
<p>There are six columns of the balance table:</p>
<ol style="list-style-type: decimal">
<li><p>Mean covariate values in the treated group (Z = 1) <em>before</em> matching.</p></li>
<li><p>Mean covariate values in the control group (Z = 0) <em>before</em> matching.</p></li>
<li><p>Standardized differences <em>before</em> matching.</p></li>
<li><p>Mean covariate values in the treated group (Z = 1) <em>after</em> matching.</p></li>
<li><p>Mean covariate values in the control group (Z = 0) <em>after</em> matching.</p></li>
<li><p>Standardized differences <em>after</em> matching.</p></li>
</ol>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>tb_example =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output_example, </span>
<span id="cb6-2"><a href="#cb6-2"></a>              <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb6-3"><a href="#cb6-3"></a>              <span class="dt">plot_propens =</span> <span class="ot">FALSE</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">print</span>(tb_example)</span></code></pre></div>
<p>Function <em>check_balance</em> may also plot the distribution of the propensity score among the treated subjects, all conrol subjects, and the matched control subjects by setting option <em>plot_propens = TRUE</em> and supplying the option <em>propens</em> with estimated propensity scores as shown below. In the figure below, the blue curve corresponds to the propensity score distribution among 1,122 treated subjects, the red curve among 1,915 control subjects, and the green curve among 1,122 matched controls. It is evident that after matching, the propensity score distribution aligns better with that of the treated subjects.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>tb_example =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output_example, </span>
<span id="cb7-2"><a href="#cb7-2"></a>              <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, </span>
<span id="cb7-3"><a href="#cb7-3"></a>                           <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb7-4"><a href="#cb7-4"></a>              <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span></code></pre></div>
</div>
</div>
<div id="introducing-the-main-function-match_2c" class="section level1">
<h1>Introducing the Main Function <em>match_2C</em></h1>
<div id="a-basic-match-with-minimal-input" class="section level2">
<h2>A Basic Match with Minimal Input</h2>
<p>Function <em>match_2C</em> is a wrapper function of <em>match_2C_list</em> with a carefully-chosen distance structure. Compare to <em>match_2C_list</em> and <em>match_2C_mat</em>, <em>match_2C</em> is less flexible; however, it requires minimal input from the users’ side, works well in most cases, and therefore is of primary interest to most users.</p>
<p>The minimal input to function <em>match_2C</em> is the following:</p>
<ol style="list-style-type: decimal">
<li>treatment indicator vector,</li>
<li>a matrix of covariates to be matched,</li>
<li>a vector of estimated propensity score, and</li>
<li>the original dataset to which match sets information is attached.</li>
</ol>
<p>By default, <em>match_2C</em> performs a statistical matching that:</p>
<ol style="list-style-type: decimal">
<li>maximally balances the marginal distribution of the propensity score in the treated and matched control group, and</li>
<li>subject to 1, minimizes the within-matched-pair Mahalanobis distances.</li>
</ol>
<p>The code chunk below displays how to perform a basic match using function <em>match_2C</em> with minimal input, and then check the balance of such a match. The balance is very good and the propensity score distributions in the treated and matched control group almost perfectly align with each other.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="co"># Perform a matching with minimal input</span></span>
<span id="cb8-2"><a href="#cb8-2"></a>matching_output =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb8-3"><a href="#cb8-3"></a>                           <span class="dt">propensity =</span> propensity, </span>
<span id="cb8-4"><a href="#cb8-4"></a>                           <span class="dt">dataset =</span> dt_Rouse)</span>
<span id="cb8-5"><a href="#cb8-5"></a>tb =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output, </span>
<span id="cb8-6"><a href="#cb8-6"></a>                   <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb8-7"><a href="#cb8-7"></a>                   <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="kw">print</span>(tb)</span></code></pre></div>
</div>
<div id="incorporating-exact-matching-constraints" class="section level2">
<h2>Incorporating Exact Matching Constraints</h2>
<p>Researchers can also incorporate the exact matching constraints by specifying the variables to be exactly matched in the option exact. In the example below, we match exactly on father’s education and mother’s education. The matching algorithm still tries to find a match that maximally balance the propensity score distribution, and then minimzies the treated-to-control total distances, subject to the exact matching constraints.</p>
<p>One can check that father’s education and mother’s education are exactly matched. Moreover, since the matching algorithm separates balancing the propensity score from exact matching, the propensity score distributions are still well balanced.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="co"># Perform a matching with minimal input</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>matching_output_with_exact =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, <span class="dt">exact =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>),</span>
<span id="cb9-3"><a href="#cb9-3"></a>                           <span class="dt">propensity =</span> propensity, </span>
<span id="cb9-4"><a href="#cb9-4"></a>                           <span class="dt">dataset =</span> dt_Rouse)</span>
<span id="cb9-5"><a href="#cb9-5"></a></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co"># Check exact matching</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="kw">head</span>(matching_output_with_exact<span class="op">$</span>matched_data_in_order[, <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, </span>
<span id="cb9-8"><a href="#cb9-8"></a>                                      <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, </span>
<span id="cb9-9"><a href="#cb9-9"></a>                                      <span class="st">&#39;propensity&#39;</span>, <span class="st">&#39;IV&#39;</span>, <span class="st">&#39;matched_set&#39;</span>)])</span>
<span id="cb9-10"><a href="#cb9-10"></a></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co"># Check overall balance</span></span>
<span id="cb9-12"><a href="#cb9-12"></a>tb =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output_with_exact, </span>
<span id="cb9-13"><a href="#cb9-13"></a>                   <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb9-14"><a href="#cb9-14"></a>                   <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span></code></pre></div>
</div>
<div id="incorporating-fine-balancing-constraints" class="section level2">
<h2>Incorporating Fine Balancing Constraints</h2>
<p>Function <em>match_2C</em> also allows incorporating the (near-)fine balancing constraints. (Near-)fine balance refers to maximally balancing the marginal distribution of a nominal variable, or more generally the joint distribution of a few nominal variables, in the treated and matched control groups. Option <em>fb</em> in the function <em>match_2C</em> serves this purpose. Once the fine balance is turned on, <em>match_2C</em> then performs a statistical matching that:</p>
<ol style="list-style-type: decimal">
<li>maximally balances the marginal distribution of nominal levels specified in the option <em>fb</em>,</li>
<li>subject to 1. maximally balances the marginal distribution of the propensity score in the treated and matched control group, and</li>
<li>subject to 2, minimizes the within-matched-pair Mahalanobis distances.</li>
</ol>
<p>The code chunk below builds upon the last match by further requiring fine balancing the nominal variable <em>dadeduc</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># Perform a matching with fine balance</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>matching_output2 =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb10-3"><a href="#cb10-3"></a>                            <span class="dt">propensity =</span> propensity, </span>
<span id="cb10-4"><a href="#cb10-4"></a>                            <span class="dt">dataset =</span> dt_Rouse,</span>
<span id="cb10-5"><a href="#cb10-5"></a>                            <span class="dt">fb_var =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>))</span></code></pre></div>
<p>We examine the balance and the variable <em>dadeduc</em> is indeed finely balanced.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># Perform a matching with fine balance</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>tb2 =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output2, </span>
<span id="cb11-3"><a href="#cb11-3"></a>                   <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb11-4"><a href="#cb11-4"></a>                   <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="kw">print</span>(tb2)</span></code></pre></div>
<p>One can further finely balance the joint distribution of multiple nominal variables. The code chunk below finely balances the joint distribution of father’s (4 levels) and mother’s (4 levels) education (<span class="math inline">\(4 \times 4 = 16\)</span> levels in total).</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># Perform a matching with fine balance on dadeduc and moneduc</span></span>
<span id="cb12-2"><a href="#cb12-2"></a>matching_output3 =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb12-3"><a href="#cb12-3"></a>                            <span class="dt">propensity =</span> propensity, </span>
<span id="cb12-4"><a href="#cb12-4"></a>                            <span class="dt">dataset =</span> dt_Rouse,</span>
<span id="cb12-5"><a href="#cb12-5"></a>                            <span class="dt">fb_var =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>))</span>
<span id="cb12-6"><a href="#cb12-6"></a>tb3 =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output2, </span>
<span id="cb12-7"><a href="#cb12-7"></a>                   <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb12-8"><a href="#cb12-8"></a>                   <span class="dt">plot_propens =</span> <span class="ot">FALSE</span>)</span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="kw">print</span>(tb3)</span></code></pre></div>
</div>
<div id="sparsifying-the-network-to-match-faster-and-match-bigger-datasets" class="section level2">
<h2>Sparsifying the Network to Match Faster and Match Bigger Datasets</h2>
<p>Sparsifying a network refers to deleting certain edges in a network. Edges deleted typically connect a treated and a control subject that are unlikely to be a good match. Using the estimated propensity score as a caliper to delete unlikely edges is the most commonly used strategy. For instance, a propensity score caliper of 0.05 would result in deleting all edges connecting one treated and one control subject whose estimated propensity score differs by more than 0.05. Sparsifying the network has potential to greatly facilitate computation (Yu et al., 2020).</p>
<p>Function <em>match_2C</em> allows users to specify two caliper sizes on the propensity scores, <em>caliper_left</em> for the left network and <em>caliper_right</em> for the right network. If users are interested in specifying a caliper other than the propensity score and/or specifying an asymmetric caliper (Yu and Rosenbaum, 2020), functions <em>match_2C_list</em> serves this purpose (see Section 4 for details). Moreover, users may further trim the number of edges using the option <em>k_left</em> and <em>k_right</em>. By default, each treated subject in the network is connected to each of the n_c control subjects. Option <em>k_left</em> allows users to specify that each treated subject gets connected only to the <em>k_left</em> control subjects who are closest to the treated subject in the propensity score in the left network. For instance, setting <em>k_left = 200</em> results in each treated subject being connected to at most 200 control subjects closest in the propensity score in the left network. Similarly, option <em>k_right</em> allows each treated subject to be connected to the closest <em>k_right</em> controls in the right network. Options <em>caliper_low</em>, <em>caliper_high</em>, <em>k_left</em>, and <em>k_right</em> can be used together.</p>
<p>Below, we give a simple example illustrating the usage of caliper and contrasting the running time of applying <em>match_2C</em> without any caliper, one caliper on the left, and both calipers on the left and the right. Using double calipers in this case roughly cuts the computation time by almost two-thirds.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># Timing the vanilla match2C function</span></span>
<span id="cb13-2"><a href="#cb13-2"></a>ptm &lt;-<span class="st"> </span><span class="kw">proc.time</span>()</span>
<span id="cb13-3"><a href="#cb13-3"></a>matching_output2 =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb13-4"><a href="#cb13-4"></a>                            <span class="dt">propensity =</span> propensity, </span>
<span id="cb13-5"><a href="#cb13-5"></a>                            <span class="dt">dataset =</span> dt_Rouse)</span>
<span id="cb13-6"><a href="#cb13-6"></a>time_vanilla =<span class="st"> </span><span class="kw">proc.time</span>() <span class="op">-</span><span class="st"> </span>ptm</span>
<span id="cb13-7"><a href="#cb13-7"></a></span>
<span id="cb13-8"><a href="#cb13-8"></a><span class="co"># Timing the match2C function with caliper on the left</span></span>
<span id="cb13-9"><a href="#cb13-9"></a>ptm &lt;-<span class="st"> </span><span class="kw">proc.time</span>()</span>
<span id="cb13-10"><a href="#cb13-10"></a>matching_output_one_caliper =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, <span class="dt">propensity =</span> propensity, </span>
<span id="cb13-11"><a href="#cb13-11"></a>                            <span class="dt">caliper_left =</span> <span class="fl">0.05</span>, <span class="dt">caliper_right =</span> <span class="fl">0.05</span>, </span>
<span id="cb13-12"><a href="#cb13-12"></a>                            <span class="dt">k_left =</span> <span class="dv">100</span>,</span>
<span id="cb13-13"><a href="#cb13-13"></a>                            <span class="dt">dataset =</span> dt_Rouse)</span>
<span id="cb13-14"><a href="#cb13-14"></a>time_one_caliper =<span class="st"> </span><span class="kw">proc.time</span>() <span class="op">-</span><span class="st"> </span>ptm</span>
<span id="cb13-15"><a href="#cb13-15"></a></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="co"># Timing the match2C function with caliper on the left and right</span></span>
<span id="cb13-17"><a href="#cb13-17"></a>ptm &lt;-<span class="st"> </span><span class="kw">proc.time</span>()</span>
<span id="cb13-18"><a href="#cb13-18"></a>matching_output_double_calipers =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb13-19"><a href="#cb13-19"></a>                            <span class="dt">propensity =</span> propensity, </span>
<span id="cb13-20"><a href="#cb13-20"></a>                            <span class="dt">caliper_left =</span> <span class="fl">0.05</span>, <span class="dt">caliper_right =</span> <span class="fl">0.05</span>, </span>
<span id="cb13-21"><a href="#cb13-21"></a>                            <span class="dt">k_left =</span> <span class="dv">100</span>, <span class="dt">k_right =</span> <span class="dv">100</span>,</span>
<span id="cb13-22"><a href="#cb13-22"></a>                            <span class="dt">dataset =</span> dt_Rouse)</span>
<span id="cb13-23"><a href="#cb13-23"></a>time_double_caliper =<span class="st"> </span><span class="kw">proc.time</span>() <span class="op">-</span><span class="st"> </span>ptm</span>
<span id="cb13-24"><a href="#cb13-24"></a></span>
<span id="cb13-25"><a href="#cb13-25"></a><span class="kw">rbind</span>(time_vanilla, time_one_caliper, time_double_caliper)[,<span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]</span></code></pre></div>
<p>Caveat: if caliper sizes are too small, the matching may be unfeasible. See the example below. In such an eventuality, users are advised to increase the caliper size and/or remove the exact matching constraints.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># Perform a matching with fine balance on dadeduc and moneduc</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>matching_output_unfeas =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, <span class="dt">propensity =</span> propensity, </span>
<span id="cb14-3"><a href="#cb14-3"></a>                                  <span class="dt">dataset =</span> dt_Rouse,</span>
<span id="cb14-4"><a href="#cb14-4"></a>                                  <span class="dt">caliper_left =</span> <span class="fl">0.001</span>)</span></code></pre></div>
</div>
<div id="force-including-certain-controls-into-the-matched-cohort" class="section level2">
<h2>Force including certain controls into the matched cohort</h2>
<p>Sometimes, researchers might want to include certain controls in the final matched cohort. Option <em>include</em> in the function <em>match_2C</em> serves this purpose. The option <em>include</em> is a binary vectors (0’s and 1’s) whose length equal to the total number of controls, with 1 in the i-th entry if the i-th control has to be included and 0 otherwise. For instance, the match below forces including the first 100 controls in our matched samples.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co"># Create a binary vector with 1&#39;s in the first 100 entries and 0 otherwise</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co"># length(include_vec) = n_c</span></span>
<span id="cb15-4"><a href="#cb15-4"></a></span>
<span id="cb15-5"><a href="#cb15-5"></a>include_vec =<span class="st"> </span><span class="kw">c</span>(<span class="kw">rep</span>(<span class="dv">1</span>, <span class="dv">100</span>), <span class="kw">rep</span>(<span class="dv">0</span>, n_c <span class="op">-</span><span class="st"> </span><span class="dv">100</span>))</span>
<span id="cb15-6"><a href="#cb15-6"></a><span class="co"># Perform a matching with minimal input</span></span>
<span id="cb15-7"><a href="#cb15-7"></a>matching_output_force_include =<span class="st"> </span><span class="kw">match_2C</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> X, </span>
<span id="cb15-8"><a href="#cb15-8"></a>                           <span class="dt">propensity =</span> propensity, </span>
<span id="cb15-9"><a href="#cb15-9"></a>                           <span class="dt">dataset =</span> dt_Rouse, </span>
<span id="cb15-10"><a href="#cb15-10"></a>                           <span class="dt">include =</span> include_vec)</span></code></pre></div>
<p>One can check that the first 100 controls in the original dataset are forced into the final matched samples.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a></span>
<span id="cb16-2"><a href="#cb16-2"></a>matched_data =<span class="st"> </span>matching_output_force_include<span class="op">$</span>data_with_matched_set_ind</span>
<span id="cb16-3"><a href="#cb16-3"></a>matched_data_control =<span class="st"> </span>matched_data[matched_data<span class="op">$</span>IV <span class="op">==</span><span class="st"> </span><span class="dv">0</span>,]</span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">head</span>(matched_data_control) <span class="co"># Check the matched_set column</span></span></code></pre></div>
</div>
</div>
<div id="function-match_2c_list-matching-with-two-user-supplied-distance-lists" class="section level1">
<h1>Function <em>match_2C_list</em>: Matching with Two User-Supplied Distance Lists</h1>
<div id="constructing-distance-lists-from-data" class="section level2">
<h2>Constructing Distance Lists from Data</h2>
<p>A distance list is the most fundamental building block for network-flow-based statistical matching. Function <em>create_list_from_mat</em> allows users to convert a distance matrix to a distance list and function <em>create_list_from_scratch</em> allows users to construct a distance list directly from data. Function <em>create_list_from_scratch</em> is highly flexible and allows users to construct a distance list tailored to their specific needs.</p>
<p>Function <em>create_list_from_scratch</em> allows users to construct a distance list without first creating a distance matrix. This is a great tool for users who are interested in experimenting/developing different matching strategies. Roughly speaking, <em>create_list_from_scratch</em> is an analogue of the function <em>match_on</em> in the package <em>optmatch</em>.</p>
<p>Currently, there are 5 default distance specifications implemented: <em>maha</em> (Mahalanobis distance), <em>L1</em> (L1 disance), <em>robust maha</em> (robust Mahalanobis distance), <em>0/1</em> (distance = 0 if and only if covariates are the same), and <em>Hamming</em> (Hamming distance), and <em>other</em> allows user-supplied distance functions. We will defer a discussion on how to use this user-supplied option to the next section.</p>
<p>The minimal input to the function <em>create_list_from_scratch</em> is treatment Z and covariate matrix X. The user may choose the distance specification via the option <em>method</em>. Other useful options include the following:</p>
<ul>
<li>Option <em>exact</em> allows users to specify variables that need to be exactly matched.</li>
<li>Option <em>p</em> allows users to specify a variable, e.g., the propensity score, as a caliper.</li>
<li>Options <em>caliper_low</em> and <em>caliper_high</em> set the size of this caliper. The size of the caliper is defined by [variable - caliper_low, variable + caliper_high]. Setting <em>caliper_low</em> and <em>caliper_high</em> to different magnitudes allows a so-called asymmetric caliper (Yu and Rosenbaum, 2020). If only <em>caliper_low</em> is used, <em>caliper_high</em> is then set to <em>caliper_low</em> by default and a symmetric caliper is used.</li>
<li>Option <em>k</em> allows users to further sparsify the network by connecting each treated only to k controls closest in the caliper.</li>
<li>Option <em>penalty</em> allows users to make the specified caliper a <em>soft</em> caliper, in the sense that the caliper is allowed to be violated at a cost of <em>penalty</em>. Option <em>penalty</em> is set to <em>Inf</em> by default, i.e., a <em>hard</em> caliper is implemented.</li>
</ul>
<p>Below, we give several examples below to illustrate its usage.</p>
<p>First, we create a list representation using the Mahalanobis/Hamming/robust Mahalanobis distance without any caliper or exact matching requirement.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a><span class="co"># Mahalanobis distance on all variables</span></span>
<span id="cb17-2"><a href="#cb17-2"></a>dist_list_vanilla_maha =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb17-3"><a href="#cb17-3"></a>                                                  <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>) </span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co"># Hamming distance on all variables</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>dist_list_vanilla_Hamming =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb17-7"><a href="#cb17-7"></a>                                                      <span class="dt">method =</span> <span class="st">&#39;Hamming&#39;</span>) </span>
<span id="cb17-8"><a href="#cb17-8"></a></span>
<span id="cb17-9"><a href="#cb17-9"></a><span class="co"># Robust Mahalanobis distance on all variables</span></span>
<span id="cb17-10"><a href="#cb17-10"></a>dist_list_vanilla_robust_maha =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb17-11"><a href="#cb17-11"></a>                                                      <span class="dt">method =</span> <span class="st">&#39;robust maha&#39;</span>) </span></code></pre></div>
<p>We further specify a symmetric propensity score caliper of size <span class="math inline">\(0.05\)</span> and <span class="math inline">\(k = 100\)</span>.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1"></a><span class="co"># Mahalanobis distance on all variables with pscore caliper</span></span>
<span id="cb18-2"><a href="#cb18-2"></a>dist_list_pscore_maha =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb18-3"><a href="#cb18-3"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb18-4"><a href="#cb18-4"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb18-5"><a href="#cb18-5"></a>                                       <span class="dt">k =</span> <span class="dv">100</span>, </span>
<span id="cb18-6"><a href="#cb18-6"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>) </span>
<span id="cb18-7"><a href="#cb18-7"></a></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="co"># Hamming distance on all variables with pscore caliper</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>dist_list_pscore_Hamming =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb18-10"><a href="#cb18-10"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb18-11"><a href="#cb18-11"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb18-12"><a href="#cb18-12"></a>                                       <span class="dt">k =</span> <span class="dv">100</span>, </span>
<span id="cb18-13"><a href="#cb18-13"></a>                                       <span class="dt">method =</span> <span class="st">&#39;Hamming&#39;</span>) </span>
<span id="cb18-14"><a href="#cb18-14"></a></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="co"># Robust Mahalanobis distance on all variables with pscore caliper</span></span>
<span id="cb18-16"><a href="#cb18-16"></a>dist_list_pscore_robust_maha =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb18-17"><a href="#cb18-17"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb18-18"><a href="#cb18-18"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb18-19"><a href="#cb18-19"></a>                                       <span class="dt">k =</span> <span class="dv">100</span>, </span>
<span id="cb18-20"><a href="#cb18-20"></a>                                       <span class="dt">method =</span> <span class="st">&#39;robust maha&#39;</span>) </span></code></pre></div>
<p>If we specify too small a caliper, the problem may fail in the sense that some treated subjects are not connected to any control. See the example below.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1"></a>dist_list_pscore_maha_hard =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb19-2"><a href="#cb19-2"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb19-3"><a href="#cb19-3"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.001</span>, </span>
<span id="cb19-4"><a href="#cb19-4"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>) </span>
<span id="cb19-5"><a href="#cb19-5"></a><span class="co">#&gt; Hard caliper fails. Please specify a soft caliper.</span></span></code></pre></div>
<p>In this case, users are advised to use a soft caliper by specifying a large penalty or increase the caliper size. See the example below.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1"></a>dist_list_pscore_maha_soft =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb20-2"><a href="#cb20-2"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb20-3"><a href="#cb20-3"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.001</span>, </span>
<span id="cb20-4"><a href="#cb20-4"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>, </span>
<span id="cb20-5"><a href="#cb20-5"></a>                                       <span class="dt">penalty =</span> <span class="dv">1000</span>) </span></code></pre></div>
<p>Next, we create a list representation without caliper; however, we insist that dad’s education is exactly matched. This can be done by setting the option <em>exact</em> to a vector of names of variables to be exactly matched.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1"></a>dist_list_exact_dadeduc_maha =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, </span>
<span id="cb21-2"><a href="#cb21-2"></a>                                                        <span class="dt">exact =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>), </span>
<span id="cb21-3"><a href="#cb21-3"></a>                                                        <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>) </span></code></pre></div>
<p>Finally, we create a list representation with an assymetric propensity score caliper and <span class="math inline">\(k = 100\)</span>; moreover, we insist that both dad’s education and mom’s education are exactly matched.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1"></a>dist_list_exact_dad_mom_with_caliper =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, </span>
<span id="cb22-2"><a href="#cb22-2"></a>                                                <span class="dt">exact =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>), </span>
<span id="cb22-3"><a href="#cb22-3"></a>                                                <span class="dt">p =</span> propensity, </span>
<span id="cb22-4"><a href="#cb22-4"></a>                                                <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb22-5"><a href="#cb22-5"></a>                                                <span class="dt">caliper_high =</span> <span class="fl">0.1</span>,</span>
<span id="cb22-6"><a href="#cb22-6"></a>                                                <span class="dt">k =</span> <span class="dv">100</span>, </span>
<span id="cb22-7"><a href="#cb22-7"></a>                                                <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>) </span></code></pre></div>
</div>
<div id="matching-with-one-or-two-distance-lists" class="section level2">
<h2>Matching with One or Two Distance Lists</h2>
<p>Function <em>match_2C_list</em> takes as input the following arguments:</p>
<ul>
<li><p>Z: A length-n vector of treatment indicator.</p></li>
<li><p>dataset: The original dataset.</p></li>
<li><p>dist_list_1: A distance list object returned by the function <em>create_list_from_scratch</em>.</p></li>
<li><p>dist_list_2: A second distance list object returned by the function <em>create_list_from_scratch</em>.</p></li>
<li><p>lambda: A penalty that controls the trade-off between two parts of the network.</p></li>
<li><p>controls: Number of controls matched to each treated. Default is set to 1.</p></li>
<li><p>overflow: A logical value indicating if overflow protection is turned on. If overflow = TRUE, then the matching is feasible as long as the left network is feasible. Default is set to FALSE.</p></li>
</ul>
<p>The key inputs are two distance list objects. The object <em>dist_list_1</em> represents the network structure of the left network, while <em>dist_list_2</em> represents the structure of the network on the right. If only one dist_list_1 is supplied (i.e., dist_list_2 = NULL), then a traditional bipartite match is performed. Option <em>lambda</em> is a tuning parameter that controls the relative trade-off between two networks.</p>
<p>We give some examples below to illustrate the usage.</p>
<div id="example-i-optimal-macthing-within-propensity-score-caliper-rosenbaum-and-rubin-1985" class="section level3">
<h3>Example I: Optimal Macthing within Propensity Score Caliper (Rosenbaum and Rubin, 1985)</h3>
<p>The classical methodology can be recovered using the following code. Note that in this example, we only need to construct one distance list and the match is a bipartite one.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1"></a><span class="co"># Construct a distance list representing the network structure on the left.</span></span>
<span id="cb23-2"><a href="#cb23-2"></a>dist_list_pscore =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb23-3"><a href="#cb23-3"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb23-4"><a href="#cb23-4"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.008</span>, </span>
<span id="cb23-5"><a href="#cb23-5"></a>                                       <span class="dt">k =</span> <span class="ot">NULL</span>, </span>
<span id="cb23-6"><a href="#cb23-6"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>)</span>
<span id="cb23-7"><a href="#cb23-7"></a></span>
<span id="cb23-8"><a href="#cb23-8"></a><span class="co"># Perform matching. Set dist_list_2 = NULL as we are </span></span>
<span id="cb23-9"><a href="#cb23-9"></a><span class="co"># performing a bipartite matching.</span></span>
<span id="cb23-10"><a href="#cb23-10"></a>matching_output_ex1 =<span class="st"> </span><span class="kw">match_2C_list</span>(Z, dt_Rouse, dist_list_pscore, </span>
<span id="cb23-11"><a href="#cb23-11"></a>                                    <span class="dt">dist_list_2 =</span> <span class="ot">NULL</span>, </span>
<span id="cb23-12"><a href="#cb23-12"></a>                                    <span class="dt">controls =</span> <span class="dv">1</span>)</span></code></pre></div>
</div>
<div id="example-ii-optimal-macthing-on-the-left-and-stringent-propensity-score-caliper-on-the-right" class="section level3">
<h3>Example II: Optimal Macthing on the Left and Stringent Propensity Score Caliper on the Right</h3>
<p>We remove the propensity score caliper in the left network and put a more stringent one on the right. This allows the algorithm to separate close pairing (using the Mahalanobis distance on the left) and balancing (using a stringent propensity score caliper on the right). One may check that in this example, this little trick does simultaneously improve the closeness in pairing AND the overall balance.</p>
<p>Note that we make the propensity score caliper on the right a soft caliper (by setting penalty = 100 instead of the detaul Inf) to ensure feasibility.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1"></a><span class="co"># Mahalanobis distance on all variables; no caliper</span></span>
<span id="cb24-2"><a href="#cb24-2"></a>dist_list_no_caliper =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="ot">NULL</span>, </span>
<span id="cb24-3"><a href="#cb24-3"></a>                                                <span class="dt">p =</span> <span class="ot">NULL</span>, </span>
<span id="cb24-4"><a href="#cb24-4"></a>                                                <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>)</span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="co"># Connect treated to controls within a stringent propensity score caliper.</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="co"># We use a soft caliper here to ensure feasibility.</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>dist_list_<span class="dv">2</span> =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(<span class="dt">Z =</span> Z, <span class="dt">X =</span> <span class="kw">rep</span>(<span class="dv">1</span>, <span class="kw">length</span>(Z)), </span>
<span id="cb24-9"><a href="#cb24-9"></a>                                       <span class="dt">exact =</span> <span class="ot">NULL</span>,</span>
<span id="cb24-10"><a href="#cb24-10"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb24-11"><a href="#cb24-11"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.002</span>, </span>
<span id="cb24-12"><a href="#cb24-12"></a>                                       <span class="dt">method =</span> <span class="st">&#39;L1&#39;</span>, </span>
<span id="cb24-13"><a href="#cb24-13"></a>                                       <span class="dt">k =</span> <span class="ot">NULL</span>,</span>
<span id="cb24-14"><a href="#cb24-14"></a>                                       <span class="dt">penalty =</span> <span class="dv">100</span>)</span>
<span id="cb24-15"><a href="#cb24-15"></a></span>
<span id="cb24-16"><a href="#cb24-16"></a>matching_output_ex2 =<span class="st"> </span><span class="kw">match_2C_list</span>(Z, dt_Rouse, </span>
<span id="cb24-17"><a href="#cb24-17"></a>                                    dist_list_no_caliper, </span>
<span id="cb24-18"><a href="#cb24-18"></a>                                    dist_list_<span class="dv">2</span>, </span>
<span id="cb24-19"><a href="#cb24-19"></a>                                    <span class="dt">lambda =</span> <span class="dv">1000</span>, <span class="dt">controls =</span> <span class="dv">1</span>)</span></code></pre></div>
</div>
<div id="example-iii-exact-matching-on-one-or-more-variable-while-balancing-others" class="section level3">
<h3>Example III: Exact Matching on One (or More) Variable while Balancing Others</h3>
<p>Suppose we would like to construct an optimal pair matching and insist two subjects in the same matched pair match exactly on father’s and mother’s education. We compare two implementations below. Our first implementation is a conventional one based on a bipartite graph:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1"></a><span class="co"># Mahalanobis distance with exact matching on dadeduc and momeduc</span></span>
<span id="cb25-2"><a href="#cb25-2"></a>dist_list_<span class="dv">1</span> =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, <span class="dt">exact =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>), </span>
<span id="cb25-3"><a href="#cb25-3"></a>                                       <span class="dt">p =</span> propensity, <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb25-4"><a href="#cb25-4"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>)</span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>matching_output_ex3_<span class="dv">1</span> =<span class="st"> </span><span class="kw">match_2C_list</span>(Z, dt_Rouse, dist_list_<span class="dv">1</span>, </span>
<span id="cb25-7"><a href="#cb25-7"></a>                                  <span class="dt">dist_list_2 =</span> <span class="ot">NULL</span>, <span class="dt">lambda =</span> <span class="ot">NULL</span>)</span></code></pre></div>
<p>Our second implementation uses the distance list on the left to ensure exact matching and the distance list on the right to balance the other covariates.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1"></a><span class="co"># Maha distance with exact matching on dadeduc and momeduc</span></span>
<span id="cb26-2"><a href="#cb26-2"></a>dist_list_<span class="dv">1</span> =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X, </span>
<span id="cb26-3"><a href="#cb26-3"></a>                                       <span class="dt">exact =</span> <span class="kw">c</span>(<span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>), </span>
<span id="cb26-4"><a href="#cb26-4"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>)</span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="co"># Maha distance on all other variables</span></span>
<span id="cb26-7"><a href="#cb26-7"></a>dist_list_<span class="dv">2</span> =<span class="st"> </span><span class="kw">create_list_from_scratch</span>(Z, X[, <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>)], </span>
<span id="cb26-8"><a href="#cb26-8"></a>                                       <span class="dt">p =</span> propensity, </span>
<span id="cb26-9"><a href="#cb26-9"></a>                                       <span class="dt">caliper_low =</span> <span class="fl">0.05</span>, </span>
<span id="cb26-10"><a href="#cb26-10"></a>                                       <span class="dt">method =</span> <span class="st">&#39;maha&#39;</span>)</span>
<span id="cb26-11"><a href="#cb26-11"></a></span>
<span id="cb26-12"><a href="#cb26-12"></a>matching_output_ex3_<span class="dv">2</span> =<span class="st"> </span><span class="kw">match_2C_list</span>(Z, dt_Rouse, dist_list_<span class="dv">1</span>, dist_list_<span class="dv">2</span>, <span class="dt">lambda =</span> <span class="dv">100</span>)</span></code></pre></div>
<p>One can easily verify that both implementations match exactly on <em>dadeduc</em> and <em>momeduc</em>; however, the second implementation achieves better overall balance.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1"></a>tb_ex3_<span class="dv">1</span> =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output_ex3_<span class="dv">1</span>, </span>
<span id="cb27-2"><a href="#cb27-2"></a>                        <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb27-3"><a href="#cb27-3"></a>                        <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="kw">print</span>(tb_ex3_<span class="dv">1</span>)</span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a>tb_ex3_<span class="dv">2</span> =<span class="st"> </span><span class="kw">check_balance</span>(Z, matching_output_ex3_<span class="dv">2</span>, </span>
<span id="cb27-8"><a href="#cb27-8"></a>                        <span class="dt">cov_list =</span> <span class="kw">c</span>(<span class="st">&#39;female&#39;</span>, <span class="st">&#39;black&#39;</span>, <span class="st">&#39;bytest&#39;</span>, <span class="st">&#39;fincome&#39;</span>, <span class="st">&#39;dadeduc&#39;</span>, <span class="st">&#39;momeduc&#39;</span>, <span class="st">&#39;propensity&#39;</span>),</span>
<span id="cb27-9"><a href="#cb27-9"></a>                        <span class="dt">plot_propens =</span> <span class="ot">TRUE</span>, <span class="dt">propens =</span> propensity)</span>
<span id="cb27-10"><a href="#cb27-10"></a><span class="kw">print</span>(tb_ex3_<span class="dv">2</span>)</span></code></pre></div>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
